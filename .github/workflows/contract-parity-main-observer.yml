name: contract-parity-main-observer

on:
  # Nightly drift detector against upstream main (non-blocking observer).
  schedule:
    - cron: "17 3 * * *" # 03:17 UTC daily
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write

jobs:
  parity-observer:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Check parity against upstream main (observer)
        id: parity
        env:
          UPSTREAM_REF: main
          CHECK_RULE_REGISTRY: "1"
          CHECK_INTERNAL_RULES: "1"
          # If you added bundle support and want to use it here, keep default USE_CONTRACTS_BUNDLE=1.
          # USE_CONTRACTS_BUNDLE: "1"
        shell: bash
        run: |
          set -euo pipefail

          echo "Running contract parity against upstream: ${UPSTREAM_REF}"
          echo ""

          # Capture output for issue body + artifact.
          # Do not let failure stop the job (continue-on-error is job-level).
          python ci/check_upstream_contracts.py 2>&1 | tee drift_report.txt

      - name: Upload drift report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: contract-parity-main-observer-report
          path: drift_report.txt

      - name: Open or update rolling drift issue
        if: steps.parity.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const ISSUE_TITLE = "Upstream contract drift detected";
            const LABELS = ["contracts", "drift", "automation"];
            // Dual-marker hardening:
            //  - SCOPE_MARKER is human-readable category
            //  - ID_MARKER is the canonical identity (search key)
            const SCOPE_MARKER = "<!-- drift-rolling-issue: contracts -->";
            const ID_MARKER = "<!-- drift-rolling-issue-id: contracts:9d3f1a2c -->";
            const FIRST_DETECTED_PREFIX = "<!-- drift-first-detected: ";
            const LAST_RESOLVED_PREFIX = "<!-- drift-last-resolved: ";
            const TAMPER_NOTE = "> \u26a0\ufe0f **Automation identity markers**: Do not remove or edit the hidden HTML markers at the top of this issue body. They are used to locate, reopen, and update this rolling issue automatically.\n";

            const reportPath = "drift_report.txt";
            const report = fs.existsSync(reportPath)
              ? fs.readFileSync(reportPath, 'utf8')
              : "(No drift report output found.)";

            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            // Keep issue bodies readable: trim extremely long logs but preserve the most useful tail.
            const MAX_CHARS = 60000;
            let clippedReport = report;
            if (clippedReport.length > MAX_CHARS) {
              clippedReport = clippedReport.slice(0, 15000)
                + "\n\n... (truncated) ...\n\n"
                + clippedReport.slice(-35000);
            }

            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchOne(query) {
              const res = await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 10
              });
              return res.data.items || [];
            }

            function hasBothMarkers(body) {
              const b = body || "";
              return b.includes(SCOPE_MARKER) && b.includes(ID_MARKER);
            }

            function extractFirstDetectedIso(body) {
              const b = body || "";
              const re = /<!--\s*drift-first-detected:\s*([0-9T:\.\-Z]+)\s*-->/;
              const m = b.match(re);
              return m ? m[1] : null;
            }

            function extractLastResolvedIso(body) {
              const b = body || "";
              const re = /<!--\s*drift-last-resolved:\s*([0-9T:\.\-Z]+)\s*-->/;
              const m = b.match(re);
              return m ? m[1] : null;
            }

            function extractLastDurationStr(body) {
              const b = body || "";
              const re = /<!--\s*drift-last-duration:\s*([^>]+?)\s*-->/;
              const m = b.match(re);
              return m ? m[1].trim() : null;
            }

            function ensureFirstDetectedMarker(body, iso) {
              // If marker exists, keep it; else insert after ID marker line (top-of-body).
              const b = body || "";
              if (b.includes("<!-- drift-first-detected:")) return b;
              const lines = b.split("\n");
              // Expected top:
              // 0: SCOPE_MARKER
              // 1: ID_MARKER
              // Insert at line 2.
              const markerLine = `<!-- drift-first-detected: ${iso} -->`;
              if (lines.length >= 2 && lines[0].includes("drift-rolling-issue") && lines[1].includes("drift-rolling-issue-id")) {
                lines.splice(2, 0, markerLine);
                return lines.join("\n");
              }
              // Fallback: prepend everything.
              return `${SCOPE_MARKER}\n${ID_MARKER}\n${markerLine}\n\n${b.trimStart()}`;
            }

            function ensureLastResolvedMarker(body, iso) {
              // If marker exists, replace it with new iso; else insert right after first-detected if present,
              // otherwise after ID marker line.
              const b = body || "";
              const markerLine = `<!-- drift-last-resolved: ${iso} -->`;

              if (b.includes("<!-- drift-last-resolved:")) {
                return b.replace(/<!--\s*drift-last-resolved:\s*([0-9T:\.\-Z]+)\s*-->/, markerLine);
              }

              const lines = b.split("\n");
              // Try to insert after first-detected marker if present.
              const fdIdx = lines.findIndex(l => l.includes("<!-- drift-first-detected:"));
              if (fdIdx !== -1) {
                lines.splice(fdIdx + 1, 0, markerLine);
                return lines.join("\n");
              }
              // Else after ID marker (line 1) => insert at line 2
              if (lines.length >= 2 && lines[0].includes("drift-rolling-issue") && lines[1].includes("drift-rolling-issue-id")) {
                lines.splice(2, 0, markerLine);
                return lines.join("\n");
              }
              // Fallback: prepend all markers.
              return `${SCOPE_MARKER}\n${ID_MARKER}\n${markerLine}\n\n${b.trimStart()}`;
            }

            function formatDuration(ms) {
              const totalSec = Math.max(0, Math.floor(ms / 1000));
              const days = Math.floor(totalSec / 86400);
              const hours = Math.floor((totalSec % 86400) / 3600);
              const mins = Math.floor((totalSec % 3600) / 60);
              const secs = totalSec % 60;
              const parts = [];
              if (days) parts.push(`${days}d`);
              if (days || hours) parts.push(`${hours}h`);
              if (days || hours || mins) parts.push(`${mins}m`);
              parts.push(`${secs}s`);
              return parts.join(" ");
            }

            function ensureDualMarkers(body) {
              const b = (body || "").trimStart();
              // Place markers at the very top, stable order.
              // If either is missing, prepend both (idempotent if already present).
              if (hasBothMarkers(b)) return b;
              // Remove any single/partial marker occurrences to avoid duplicates.
              const cleaned = b
                .replaceAll(SCOPE_MARKER, "")
                .replaceAll(ID_MARKER, "")
                .trimStart();
              return `${SCOPE_MARKER}\n${ID_MARKER}\n\n${cleaned}`;
            }

            async function findRollingIssue(state) {
              // 1) ID-marker search (canonical identity)
              const byIdQ = `${repoQ} is:issue in:body "${ID_MARKER}" is:${state}`;
              const idItems = await searchOne(byIdQ);
              const idHit = idItems.find(i => (i.body || "").includes(ID_MARKER)) || null;
              if (idHit) return { issue: idHit, foundBy: "id_marker" };

              // 2) Scope-marker fallback (older identity)
              const byScopeQ = `${repoQ} is:issue in:body "${SCOPE_MARKER}" is:${state}`;
              const scopeItems = await searchOne(byScopeQ);
              const scopeHit = scopeItems.find(i => (i.body || "").includes(SCOPE_MARKER)) || null;
              if (scopeHit) return { issue: scopeHit, foundBy: "scope_marker" };

              // 3) Title-based fallback (exact title) in case markers were removed
              const byTitleQ = `${repoQ} is:issue in:title "${ISSUE_TITLE}" is:${state}`;
              const titleItems = await searchOne(byTitleQ);
              const titleHit = titleItems.find(i => i.title === ISSUE_TITLE) || null;
              if (titleHit) return { issue: titleHit, foundBy: "title" };

              return { issue: null, foundBy: "none" };
            }

            function bodyWithTamperWarning(bodyText) {
              // Ensure the warning exists near the top (after markers).
              // We keep it lightweight and idempotent.
              if ((bodyText || "").includes("Automation identity markers")) return bodyText;
              const lines = (bodyText || "").split("\n");
              // After first blank line following markers block, insert warning.
              // Markers are first 2 lines, followed by blank line.
              lines.splice(3, 0, TAMPER_NOTE.trimEnd(), "");
              return lines.join("\n");
            }

            // Embed dual markers at top of body for stable identity via Search API.
            let body = [
              SCOPE_MARKER,
              ID_MARKER,
              "",
              "## Contract parity drift detected",
              "",
              `**Time (UTC):** ${now}`,
              `**Workflow run:** ${runUrl}`,
              "",
              "This repository vendors contract artifacts from the producer repo. The nightly observer checks parity against upstream `main` and detected drift.",
              "",
              "### Next actions",
              "1. Review the drift report below.",
              "2. Decide whether to update the pinned `UPSTREAM_REF` tag (preferred) or sync vendored contracts.",
              "3. If producer changes are intentional, cut a new producer release tag and update this repo's pin.",
              "",
              "### Drift report",
              "```",
              clippedReport.trimEnd(),
              "```",
              "",
              "_This issue is maintained automatically and will be updated on subsequent drift detections._"
            ].join("\n");
            body = bodyWithTamperWarning(body);

            // Find rolling issue:
            //  - Prefer ID marker identity
            //  - Fall back to scope marker, then exact title if markers got removed
            let found = await findRollingIssue("open");
            let existing = found.issue;
            let reopened = false;
            let foundBy = found.foundBy;
            let markersRepaired = false;
            let firstDetectedIso = null;
            let firstDetectedWasRepaired = false;

            if (!existing) {
              found = await findRollingIssue("closed");
              existing = found.issue;
              foundBy = found.foundBy;
              if (existing) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  state: "open"
                });
                reopened = true;
                core.info(`Reopened issue #${existing.number}`);
              }
            }

            if (!existing) {
              // Still not found: create it once.
              firstDetectedIso = now; // new unresolved period starts now
              const created = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: ISSUE_TITLE,
                body: ensureFirstDetectedMarker(body, firstDetectedIso),
                labels: LABELS
              });
              existing = created.data;
              foundBy = "created";
              core.info(`Created issue: ${created.data.html_url}`);
            } else {
              // Determine first-detected time:
              // - If reopening (was closed), start a new unresolved period now.
              // - If already open, preserve existing marker; if missing, repair to now (tamper/self-heal).
              if (reopened) {
                firstDetectedIso = now;
              } else {
                firstDetectedIso = extractFirstDetectedIso(existing.body || "") || null;
                if (!firstDetectedIso) {
                  firstDetectedIso = now;
                  firstDetectedWasRepaired = true;
                }
              }

              // If found by fallback (title/scope), markers may be missing or partial.
              // Enforce dual markers (self-healing).
              let patchedBody = ensureDualMarkers(existing.body || "");
              patchedBody = ensureFirstDetectedMarker(patchedBody, firstDetectedIso);
              // Also ensure the tamper warning exists.
              patchedBody = bodyWithTamperWarning(patchedBody);
              if ((existing.body || "") !== patchedBody) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  body: patchedBody
                });
                core.info(`Enforced dual markers on issue #${existing.number} (found by: ${foundBy}).`);
                existing = { ...existing, body: patchedBody };
                // If we had to update the body, assume markers/warning were missing/edited.
                markersRepaired = true;
              }

              // Ensure title is set (optional cosmetic) while marker remains identity.
              // This is safe even if someone renamed it manually.
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  title: ISSUE_TITLE
                });
              } catch (e) {
                core.info(`Could not set title (non-fatal): ${e}`);
              }

              // Ensure labels exist on the rolling issue (non-fatal if labels are restricted).
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  labels: LABELS
                });
              } catch (e) {
                core.info(`Could not add labels (may be restricted): ${e}`);
              }
            }

            // Compute unresolved duration and inject into the body we'll publish.
            let durationStr = "unknown";
            try {
              const fdMs = Date.parse(firstDetectedIso || "");
              const nowMs = Date.parse(now);
              if (!Number.isNaN(fdMs) && !Number.isNaN(nowMs)) {
                durationStr = formatDuration(nowMs - fdMs);
              }
            } catch (e) {
              // keep "unknown"
            }

            // Compute "time since last green" from drift-last-resolved marker if present.
            let lastResolvedIso = null;
            let sinceGreenStr = null;
            try {
              lastResolvedIso = extractLastResolvedIso(existing && existing.body ? existing.body : "");
              if (lastResolvedIso) {
                const lrMs = Date.parse(lastResolvedIso);
                const nowMs2 = Date.parse(now);
                if (!Number.isNaN(lrMs) && !Number.isNaN(nowMs2) && nowMs2 >= lrMs) {
                  sinceGreenStr = formatDuration(nowMs2 - lrMs);
                } else if (!Number.isNaN(lrMs) && !Number.isNaN(nowMs2) && nowMs2 < lrMs) {
                  // clock skew / edited marker; still surface iso
                  sinceGreenStr = "0s";
                }
              }
            } catch (e) {
              // leave nulls
            }
            const hasLastResolved = !!lastResolvedIso;

            // Previous resolved duration (from last green close), if present.
            // This is stable during an unresolved drift period and helps prioritize chronic/slow-to-fix drift.
            const prevResolvedAfterStr = extractLastDurationStr(
              existing && existing.body ? existing.body : ""
            );
            const hasPrevResolved = !!prevResolvedAfterStr;

            // Add lifecycle fields just below the header section.
            // We'll do this by inserting after the "## Contract parity drift detected" line.
            function injectDurationFields(bodyText) {
              const lines = (bodyText || "").split("\n");
              const idx = lines.findIndex(l => l.trim() === "## Contract parity drift detected");
              if (idx === -1) return bodyText;
              // Insert after the header and a blank line (header is followed by blank line currently).
              const insertAt = Math.min(idx + 2, lines.length);

              const fields = [
                `**First detected (UTC):** ${firstDetectedIso}`,
                `**Unresolved drift duration:** ${durationStr}`,
              ];

              // Only include last-resolved fields if marker exists.
              if (hasLastResolved) {
                fields.push(`**Last resolved (UTC):** ${lastResolvedIso}`);
                fields.push(`**Time since last green:** ${sinceGreenStr ?? "n/a"}`);
              }

              // Only include previous resolved duration if marker exists.
              if (hasPrevResolved) {
                fields.push(`**Previous resolved after:** ${prevResolvedAfterStr}`);
              }

              fields.push("");

              // Avoid duplicating if rerun: remove existing lifecycle lines first.
              const cleaned = lines.filter(l =>
                !l.startsWith("**First detected (UTC):**") &&
                !l.startsWith("**Unresolved drift duration:**") &&
                !l.startsWith("**Last resolved (UTC):**") &&
                !l.startsWith("**Time since last green:**") &&
                !l.startsWith("**Previous resolved after:**")
              );
              cleaned.splice(insertAt, 0, ...fields);
              return cleaned.join("\n");
            }

            body = ensureFirstDetectedMarker(body, firstDetectedIso);
            body = injectDurationFields(body);

            // If markers were repaired, leave a visible breadcrumb to discourage manual edits.
            if (markersRepaired || firstDetectedWasRepaired) {
              const tamperComment = [
                "‚ö†Ô∏è **Marker tamper detected and repaired**",
                "",
                "This rolling issue is located and managed by hidden HTML markers in the issue body.",
                "One or more identity markers (and/or first-detected marker) were missing or edited, so the observer workflow restored them automatically.",
                "",
                "Please avoid editing or removing the hidden markers at the top of the issue body.",
                `Workflow run: ${runUrl}`,
              ].join("\n");
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: tamperComment
              });
            }

            // Update body (keeps latest report visible)
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body
            });

            // Add comment (keeps a timeline of drift detections)
            const comment = [
              reopened ? `üîÑ Drift detected again (issue reopened) at **${now}**.` : `Drift detected again at **${now}**.`,
              `Workflow run: ${runUrl}`,
              "",
              `_Rolling issue identity: dual-marker (fallback used: ${foundBy})._`,
              `**Unresolved drift duration:** ${durationStr}`,
              "",
              "```",
              clippedReport.trimEnd(),
              "```"
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            core.info(`Updated and commented on issue #${existing.number}`);

      - name: Auto-close rolling drift issue when parity returns to green
        if: steps.parity.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const ISSUE_TITLE = "Upstream contract drift detected";
            const SCOPE_MARKER = "<!-- drift-rolling-issue: contracts -->";
            const ID_MARKER = "<!-- drift-rolling-issue-id: contracts:9d3f1a2c -->";
            const LAST_RESOLVED_PREFIX = "<!-- drift-last-resolved: ";
            const LAST_DURATION_PREFIX = "<!-- drift-last-duration: ";
            const TAMPER_NOTE = "> \u26a0\ufe0f **Automation identity markers**: Do not remove or edit the hidden HTML markers at the top of this issue body. They are used to locate, reopen, and update this rolling issue automatically.\n";
            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchOne(query) {
              const res = await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 10
              });
              return res.data.items || [];
            }

            function hasBothMarkers(body) {
              const b = body || "";
              return b.includes(SCOPE_MARKER) && b.includes(ID_MARKER);
            }
            function ensureDualMarkers(body) {
              const b = (body || "").trimStart();
              if (hasBothMarkers(b)) return b;
              const cleaned = b
                .replaceAll(SCOPE_MARKER, "")
                .replaceAll(ID_MARKER, "")
                .trimStart();
              return `${SCOPE_MARKER}\n${ID_MARKER}\n\n${cleaned}`;
            }

            function ensureLastResolvedMarker(body, iso) {
              const b = body || "";
              const markerLine = `<!-- drift-last-resolved: ${iso} -->`;
              if (b.includes("<!-- drift-last-resolved:")) {
                return b.replace(/<!--\s*drift-last-resolved:\s*([0-9T:\.\-Z]+)\s*-->/, markerLine);
              }
              const lines = b.split("\n");
              // Insert after ID marker (line 1) by default.
              if (lines.length >= 2 && lines[0].includes("drift-rolling-issue") && lines[1].includes("drift-rolling-issue-id")) {
                // If there's also a first-detected marker on line 2, insert after it.
                const fdIdx = lines.findIndex(l => l.includes("<!-- drift-first-detected:"));
                if (fdIdx !== -1) {
                  lines.splice(fdIdx + 1, 0, markerLine);
                } else {
                  lines.splice(2, 0, markerLine);
                }
                return lines.join("\n");
              }
              return `${SCOPE_MARKER}\n${ID_MARKER}\n${markerLine}\n\n${b.trimStart()}`;
            }

            function formatDuration(ms) {
              const totalSec = Math.max(0, Math.floor(ms / 1000));
              const days = Math.floor(totalSec / 86400);
              const hours = Math.floor((totalSec % 86400) / 3600);
              const mins = Math.floor((totalSec % 3600) / 60);
              const secs = totalSec % 60;
              const parts = [];
              if (days) parts.push(`${days}d`);
              if (days || hours) parts.push(`${hours}h`);
              if (days || hours || mins) parts.push(`${mins}m`);
              parts.push(`${secs}s`);
              return parts.join(" ");
            }

            function bodyWithTamperWarning(bodyText) {
              if ((bodyText || "").includes("Automation identity markers")) return bodyText;
              const lines = (bodyText || "").split("\n");
              lines.splice(3, 0, TAMPER_NOTE.trimEnd(), "");
              return lines.join("\n");
            }

            function extractFirstDetectedIso(body) {
              const b = body || "";
              const re = /<!--\s*drift-first-detected:\s*([0-9T:\.\-Z]+)\s*-->/;
              const m = b.match(re);
              return m ? m[1] : null;
            }

            // Prefer ID-marker identity; fall back to scope-marker, then exact title.
            let foundBy = "id_marker";
            let items = await searchOne(`${repoQ} is:issue in:body "${ID_MARKER}" is:open`);
            let existing = items.find(i => (i.body || "").includes(ID_MARKER)) || null;

            if (!existing) {
              foundBy = "scope_marker";
              items = await searchOne(`${repoQ} is:issue in:body "${SCOPE_MARKER}" is:open`);
              existing = items.find(i => (i.body || "").includes(SCOPE_MARKER)) || null;
            }

            if (!existing) {
              foundBy = "title";
              items = await searchOne(`${repoQ} is:issue in:title "${ISSUE_TITLE}" is:open`);
              existing = items.find(i => i.title === ISSUE_TITLE) || null;
            }

            if (!existing) {
              core.info("No open drift issue found; nothing to close.");
              return;
            }

            // Enforce markers (self-healing) before closing, stamp last-resolved,
            // and surface last-resolved fields in the visible body.
            let patchedBody = ensureDualMarkers(existing.body || "");
            patchedBody = ensureLastResolvedMarker(patchedBody, now);
            patchedBody = bodyWithTamperWarning(patchedBody);

            // Compute "Resolved after" duration using first-detected -> now, if first-detected exists.
            const firstDetectedIso = extractFirstDetectedIso(patchedBody) || null;
            let resolvedAfterStr = "n/a";
            if (firstDetectedIso) {
              const fdMs = Date.parse(firstDetectedIso);
              const nowMs = Date.parse(now);
              if (!Number.isNaN(fdMs) && !Number.isNaN(nowMs) && nowMs >= fdMs) {
                resolvedAfterStr = formatDuration(nowMs - fdMs);
              } else if (!Number.isNaN(fdMs) && !Number.isNaN(nowMs) && nowMs < fdMs) {
                resolvedAfterStr = "0s";
              }
            }

            // Stamp last-duration marker (even if n/a, it's still explicit and stable).
            patchedBody = ensureLastDurationMarker(patchedBody, resolvedAfterStr);

            // Inject/refresh header-visible fields:
            // - keep existing first-detected if present
            // - set last-resolved to now
            // - set time since last green to 0s
            function injectLifecycleFields(bodyText) {
              const lines = (bodyText || "").split("\n");
              const idx = lines.findIndex(l => l.trim() === "## Contract parity drift detected");
              if (idx === -1) return bodyText;

              // Remove existing lifecycle lines (idempotent).
              const cleaned = lines.filter(l =>
                !l.startsWith("**First detected (UTC):**") &&
                !l.startsWith("**Unresolved drift duration:**") &&
                !l.startsWith("**Last resolved (UTC):**") &&
                !l.startsWith("**Time since last green:**") &&
                !l.startsWith("**Resolved after:**")
              );

              const fdIso = extractFirstDetectedIso(bodyText);
              const hasFirstDetected = !!fdIso;
              // On green, we always stamp last-resolved = now, but keep this conditional to avoid weird states.
              const hasLastResolved = !!now;

              const fields = [];

              // Only show first-detected-derived fields if marker exists.
              if (hasFirstDetected) {
                fields.push(`**First detected (UTC):** ${fdIso}`);
                fields.push(`**Unresolved drift duration:** n/a`);
                fields.push(`**Resolved after:** ${resolvedAfterStr}`);
              }

              // Always show last-resolved fields on green (we stamp them), but still guarded.
              if (hasLastResolved) {
                fields.push(`**Last resolved (UTC):** ${now}`);
                fields.push(`**Time since last green:** 0s`);
              }

              fields.push("");

              const insertAt = Math.min(idx + 2, cleaned.length);
              cleaned.splice(insertAt, 0, ...fields);
              return cleaned.join("\n");
            }

            patchedBody = injectLifecycleFields(patchedBody);

            if ((existing.body || "") !== patchedBody) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: patchedBody
              });
              core.info(`Enforced dual markers on issue #${existing.number} during auto-close (found by: ${foundBy}).`);

              // Leave a tamper warning comment if we had to repair body markers/warning.
              const tamperComment = [
                "\u26a0\ufe0f **Marker tamper detected and repaired**",
                "",
                "This rolling issue is located and managed by hidden HTML markers in the issue body.",
                "One or more identity markers and/or lifecycle markers were missing or edited, so the observer workflow restored them automatically.",
                "",
                "Please avoid editing or removing the hidden markers at the top of the issue body.",
                `Workflow run: ${runUrl}`,
              ].join("\n");
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: tamperComment
              });
            }

            // Comment "Resolved" with context.
            const comment = [
              `‚úÖ Resolved at **${now}**.`,
              `Parity is green against upstream \`main\`.`,
              `Workflow run: ${runUrl}`,
              "",
              "If drift reappears, this issue will be reopened automatically by the observer.",
              "",
              `_Rolling issue identity: dual-marker (fallback used: ${foundBy})._`
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            // Close the issue.
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              state: "closed"
            });

            core.info(`Closed drift issue #${existing.number}`);

      - name: Summary
        if: always()
        run: |
          echo "Observer workflow complete."
          if [[ "${{ steps.parity.outcome }}" == "failure" ]]; then
            echo "Parity failed: drift issue opened/updated."
          else
            echo "Parity OK: drift issue (if any) auto-closed."
          fi
