name: contract-parity-main-observer

on:
  # Nightly drift detector against upstream main (non-blocking observer).
  schedule:
    - cron: "17 3 * * *" # 03:17 UTC daily
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write

jobs:
  parity-observer:
    runs-on: ubuntu-latest
    continue-on-error: true
    env:
      # Required: observer must run in explicit CI mode.
      CI: "true"
      # Drift budget (hours). If unresolved drift exceeds this, we escalate.
      DRIFT_BUDGET_HOURS: "48"
      # Escalation labels applied to the rolling issue when budget breached.
      DRIFT_BUDGET_LABELS: "priority:high,drift-budget-breached"
      # Optional: who to ping when budget is breached (comma-separated GitHub handles without @).
      # Example: "HanzoRazer,platform-owner,oncall-eng"
      DRIFT_BUDGET_PING: ""
      # Label conventions (configurable)
      DRIFT_TRIAGED_LABEL: "triaged"
      DRIFT_NEEDS_ONCALL_LABEL: "needs-oncall"
      DRIFT_ONCALL_ASSIGNED_LABEL: "oncall-assigned"
      # Oncall assignment (choose one):
      # 1) Fixed assignee:
      DRIFT_ONCALL_ASSIGNEE: ""
      # 2) Daily rotation (comma-separated, no @). Example: "alice,bob,carol"
      DRIFT_ONCALL_ROTATION: ""
      # If set, add the issue to this GitHub Projects v2 project (node id).
      # Example: "PVT_kwDOA...": ProjectV2 node_id.
      DRIFT_PROJECT_NODE_ID: ""
    steps:
      - uses: actions/checkout@v4
      - name: Require explicit CI=true
        shell: bash
        run: |
          if [[ "${CI:-}" != "true" ]]; then
            echo "Observer must run with CI=true explicitly."
            echo "Fix: set env: CI: \"true\" at the job level in contract-parity-main-observer.yml"
            exit 1
          fi
      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"
      - name: Forbid DRIFT_ONCALL_ASSIGNEE override in CI
        shell: bash
        env:
          DRIFT_ONCALL_ASSIGNEE: ${{ env.DRIFT_ONCALL_ASSIGNEE }}
          CI: ${{ env.CI }}
          GITHUB_ACTIONS: ${{ env.GITHUB_ACTIONS }}
        run: |
          if [[ "${CI:-}" == "true" || "${GITHUB_ACTIONS:-}" == "true" ]]; then
            if [[ -n "${DRIFT_ONCALL_ASSIGNEE:-}" ]]; then
              echo "DRIFT_ONCALL_ASSIGNEE override is forbidden in CI. Use .github/oncall_rotation.json instead."
              exit 1
            fi
          fi
      - name: Install jsonschema
        run: python -m pip install --upgrade pip jsonschema
      - name: Verify oncall rotation schema + manifest
        run: |
          python scripts/validate_oncall_rotation_schema.py
          python scripts/check_oncall_rotation_manifest.py
          python scripts/check_oncall_rotation_schema_manifest.py

      - name: Require oncall provenance manifests
        run: |
          test -f .github/oncall_rotation.manifest.json
          test -f .github/oncall_rotation.schema.manifest.json

      - name: Check parity against upstream main (observer)
        id: parity
        env:
          UPSTREAM_REF: main
          CHECK_RULE_REGISTRY: "1"
          CHECK_INTERNAL_RULES: "1"
          # If you added bundle support and want to use it here, keep default USE_CONTRACTS_BUNDLE=1.
          # USE_CONTRACTS_BUNDLE: "1"
        shell: bash
        run: |
          set -euo pipefail

          echo "Running contract parity against upstream: ${UPSTREAM_REF}"
          echo ""

          # Capture output for issue body + artifact.
          # Do not let failure stop the job (continue-on-error is job-level).
          python ci/check_upstream_contracts.py 2>&1 | tee drift_report.txt

      - name: Upload drift report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: contract-parity-main-observer-report
          path: drift_report.txt

      - name: Open or update rolling drift issue
        if: steps.parity.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Defense in depth: require explicit CI=true even inside the script.
            const ciVal = (process.env.CI || "").trim();
            if (ciVal !== "true") {
              throw new Error(
                `Observer script must run with CI=true explicitly (got CI='${ciVal || "(unset)"}').`
              );
            }

            function safeReadJson(path) {
              try {
                if (!fs.existsSync(path)) return null;
                return JSON.parse(fs.readFileSync(path, "utf8"));
              } catch (e) {
                core.info(`Could not read JSON ${path} (non-fatal): ${e}`);
                return null;
              }
            }

            function mustExist(path) {
              if (!fs.existsSync(path)) {
                throw new Error(`Missing required file for provenance: ${path}`);
              }
            }

            function shortSha(sha) {
              if (!sha || typeof sha !== "string") return null;
              const s = sha.trim();
              return s.length >= 12 ? s.slice(0, 12) : s;
            }

            // Remove ALL instances of a given marker key (even if duplicates exist).
            function stripAllMarkers(bodyText, key) {
              const body = (bodyText || "");
              const re = new RegExp(`^\\s*<!--\\s*${key}:\\s*[^>]*-->\\s*$`, "gm");
              const stripped = body.replace(re, "").replace(/\n{3,}/g, "\n\n");
              return stripped.trimEnd() + "\n";
            }

            // Insert exactly ONE marker in a canonical position.
            // 1) strip all existing instances (dedupe)
            // 2) insert once after drift-rolling-issue marker if present, else at top
            function upsertUniqueMarker(bodyText, key, value) {
              const marker = `<!-- ${key}: ${value} -->`;
              const cleaned = stripAllMarkers(bodyText, key);
              const lines = cleaned.split("\n");
              const idIdx = lines.findIndex(l => l.includes("drift-rolling-issue"));
              const insertAt = idIdx >= 0 ? idIdx + 1 : 0;
              if (lines.length === 1 && lines[0] === "") {
                return marker + "\n";
              }
              lines.splice(insertAt, 0, marker);
              return lines.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd() + "\n";
            }

            // Ensure marker lines are unique within a comment payload.
            function uniqueMarkerLines(lines) {
              const seen = new Set();
              const out = [];
              for (const l of (lines || [])) {
                if (typeof l !== "string") continue;
                const s = l.trimEnd();
                if (!s) { out.push(l); continue; }
                if (s.startsWith("<!--") && s.endsWith("-->")) {
                  if (seen.has(s)) continue;
                  seen.add(s);
                }
                out.push(l);
              }
              return out;
            }

            function assertOncallDecision(picked) {
              if (!picked || typeof picked !== "object") {
                throw new Error("Oncall selection failed: pickOncallDecision() returned null/invalid");
              }
              const assignee = picked.assignee;
              if (typeof assignee !== "string" || !assignee.trim()) {
                throw new Error("Oncall selection failed: missing/empty assignee");
              }
              if (assignee.trim().startsWith("@")) {
                throw new Error(`Oncall selection failed: assignee must not start with '@' (got ${assignee})`);
              }
              if (!picked.decision || typeof picked.decision !== "object") {
                throw new Error("Oncall selection failed: missing decision object");
              }
              return { assignee: assignee.trim(), decision: picked.decision };
            }

            // Provenance sources (manifest is the contract-locked sha)
            const ROTATION_MANIFEST_PATH = ".github/oncall_rotation.manifest.json";
            const ROTATION_SCHEMA_PATH = ".github/oncall_rotation.schema.json";
            const ROTATION_SCHEMA_MANIFEST_PATH = ".github/oncall_rotation.schema.manifest.json";

            // Enforce provenance prerequisites: manifests must exist.
            mustExist(ROTATION_MANIFEST_PATH);
            mustExist(ROTATION_SCHEMA_MANIFEST_PATH);

            const rotationManifest = safeReadJson(ROTATION_MANIFEST_PATH);
            const rotationSchema = safeReadJson(ROTATION_SCHEMA_PATH);
            const schemaManifest = safeReadJson(ROTATION_SCHEMA_MANIFEST_PATH);

            const rotationSha256 = rotationManifest && typeof rotationManifest.sha256 === "string"
              ? rotationManifest.sha256.trim()
              : null;
            const rotationShaShort = shortSha(rotationSha256);

            const schemaSha256 = schemaManifest && typeof schemaManifest.sha256 === "string"
              ? schemaManifest.sha256.trim()
              : null;
            const schemaShaShort = shortSha(schemaSha256);

            const rotationSchemaVersion = rotationSchema && typeof rotationSchema.schema_version === "string"
              ? rotationSchema.schema_version.trim()
              : null;

            // Hard fail if manifests exist but don't contain sha256 fields.
            if (!rotationSha256) throw new Error(`Missing sha256 in ${ROTATION_MANIFEST_PATH}`);
            if (!schemaSha256) throw new Error(`Missing sha256 in ${ROTATION_SCHEMA_MANIFEST_PATH}`);

            const ISSUE_TITLE = "Upstream contract drift detected";
            const LABELS = ["contracts", "drift", "automation"];
            // Dual-marker hardening:
            //  - SCOPE_MARKER is human-readable category
            //  - ID_MARKER is the canonical identity (search key)
            const SCOPE_MARKER = "<!-- drift-rolling-issue: contracts -->";
            const ID_MARKER = "<!-- drift-rolling-issue-id: contracts:9d3f1a2c -->";
            const FIRST_DETECTED_PREFIX = "<!-- drift-first-detected: ";
            const LAST_RESOLVED_PREFIX = "<!-- drift-last-resolved: ";
            const TAMPER_NOTE = "> \u26a0\ufe0f **Automation identity markers**: Do not remove or edit the hidden HTML markers at the top of this issue body. They are used to locate, reopen, and update this rolling issue automatically.\n";

            const reportPath = "drift_report.txt";
            const report = fs.existsSync(reportPath)
              ? fs.readFileSync(reportPath, 'utf8')
              : "(No drift report output found.)";

            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            // Keep issue bodies readable: trim extremely long logs but preserve the most useful tail.
            const MAX_CHARS = 60000;
            let clippedReport = report;
            if (clippedReport.length > MAX_CHARS) {
              clippedReport = clippedReport.slice(0, 15000)
                + "\n\n... (truncated) ...\n\n"
                + clippedReport.slice(-35000);
            }

            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchOne(query) {
              const res = await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 10
              });
              return res.data.items || [];
            }

            function hasBothMarkers(body) {
              const b = body || "";
              return b.includes(SCOPE_MARKER) && b.includes(ID_MARKER);
            }

            function extractFirstDetectedIso(body) {
              const b = body || "";
              const re = /<!--\s*drift-first-detected:\s*([0-9T:\.\-Z]+)\s*-->/;
              const m = b.match(re);
              return m ? m[1] : null;
            }

            function extractLastResolvedIso(body) {
              const b = body || "";
              const re = /<!--\s*drift-last-resolved:\s*([0-9T:\.\-Z]+)\s*-->/;
              const m = b.match(re);
              return m ? m[1] : null;
            }

            function extractLastDurationStr(body) {
              const b = body || "";
              const re = /<!--\s*drift-last-duration:\s*([^>]+?)\s*-->/;
              const m = b.match(re);
              return m ? m[1].trim() : null;
            }

            function ensureFirstDetectedMarker(body, iso) {
              // If marker exists, keep it; else insert after ID marker line (top-of-body).
              const b = body || "";
              if (b.includes("<!-- drift-first-detected:")) return b;
              const lines = b.split("\n");
              // Expected top:
              // 0: SCOPE_MARKER
              // 1: ID_MARKER
              // Insert at line 2.
              const markerLine = `<!-- drift-first-detected: ${iso} -->`;
              if (lines.length >= 2 && lines[0].includes("drift-rolling-issue") && lines[1].includes("drift-rolling-issue-id")) {
                lines.splice(2, 0, markerLine);
                return lines.join("\n");
              }
              // Fallback: prepend everything.
              return `${SCOPE_MARKER}\n${ID_MARKER}\n${markerLine}\n\n${b.trimStart()}`;
            }

            function ensureLastResolvedMarker(body, iso) {
              // If marker exists, replace it with new iso; else insert right after first-detected if present,
              // otherwise after ID marker line.
              const b = body || "";
              const markerLine = `<!-- drift-last-resolved: ${iso} -->`;

              if (b.includes("<!-- drift-last-resolved:")) {
                return b.replace(/<!--\s*drift-last-resolved:\s*([0-9T:\.\-Z]+)\s*-->/, markerLine);
              }

              const lines = b.split("\n");
              // Try to insert after first-detected marker if present.
              const fdIdx = lines.findIndex(l => l.includes("<!-- drift-first-detected:"));
              if (fdIdx !== -1) {
                lines.splice(fdIdx + 1, 0, markerLine);
                return lines.join("\n");
              }
              // Else after ID marker (line 1) => insert at line 2
              if (lines.length >= 2 && lines[0].includes("drift-rolling-issue") && lines[1].includes("drift-rolling-issue-id")) {
                lines.splice(2, 0, markerLine);
                return lines.join("\n");
              }
              // Fallback: prepend all markers.
              return `${SCOPE_MARKER}\n${ID_MARKER}\n${markerLine}\n\n${b.trimStart()}`;
            }

            function formatDuration(ms) {
              const totalSec = Math.max(0, Math.floor(ms / 1000));
              const days = Math.floor(totalSec / 86400);
              const hours = Math.floor((totalSec % 86400) / 3600);
              const mins = Math.floor((totalSec % 3600) / 60);
              const secs = totalSec % 60;
              const parts = [];
              if (days) parts.push(`${days}d`);
              if (days || hours) parts.push(`${hours}h`);
              if (days || hours || mins) parts.push(`${mins}m`);
              parts.push(`${secs}s`);
              return parts.join(" ");
            }

            function ensureDualMarkers(body) {
              const b = (body || "").trimStart();
              // Place markers at the very top, stable order.
              // If either is missing, prepend both (idempotent if already present).
              if (hasBothMarkers(b)) return b;
              // Remove any single/partial marker occurrences to avoid duplicates.
              const cleaned = b
                .replaceAll(SCOPE_MARKER, "")
                .replaceAll(ID_MARKER, "")
                .trimStart();
              return `${SCOPE_MARKER}\n${ID_MARKER}\n\n${cleaned}`;
            }

            async function findRollingIssue(state) {
              // 1) ID-marker search (canonical identity)
              const byIdQ = `${repoQ} is:issue in:body "${ID_MARKER}" is:${state}`;
              const idItems = await searchOne(byIdQ);
              const idHit = idItems.find(i => (i.body || "").includes(ID_MARKER)) || null;
              if (idHit) return { issue: idHit, foundBy: "id_marker" };

              // 2) Scope-marker fallback (older identity)
              const byScopeQ = `${repoQ} is:issue in:body "${SCOPE_MARKER}" is:${state}`;
              const scopeItems = await searchOne(byScopeQ);
              const scopeHit = scopeItems.find(i => (i.body || "").includes(SCOPE_MARKER)) || null;
              if (scopeHit) return { issue: scopeHit, foundBy: "scope_marker" };

              // 3) Title-based fallback (exact title) in case markers were removed
              const byTitleQ = `${repoQ} is:issue in:title "${ISSUE_TITLE}" is:${state}`;
              const titleItems = await searchOne(byTitleQ);
              const titleHit = titleItems.find(i => i.title === ISSUE_TITLE) || null;
              if (titleHit) return { issue: titleHit, foundBy: "title" };

              return { issue: null, foundBy: "none" };
            }

            function bodyWithTamperWarning(bodyText) {
              // Ensure the warning exists near the top (after markers).
              // We keep it lightweight and idempotent.
              if ((bodyText || "").includes("Automation identity markers")) return bodyText;
              const lines = (bodyText || "").split("\n");
              // After first blank line following markers block, insert warning.
              // Markers are first 2 lines, followed by blank line.
              lines.splice(3, 0, TAMPER_NOTE.trimEnd(), "");
              return lines.join("\n");
            }

            // Embed dual markers at top of body for stable identity via Search API.
            let body = [
              SCOPE_MARKER,
              ID_MARKER,
              "",
              "## Contract parity drift detected",
              "",
              `**Time (UTC):** ${now}`,
              `**Workflow run:** ${runUrl}`,
              "",
              "This repository vendors contract artifacts from the producer repo. The nightly observer checks parity against upstream `main` and detected drift.",
              "",
              "### Next actions",
              "1. Review the drift report below.",
              "2. Decide whether to update the pinned `UPSTREAM_REF` tag (preferred) or sync vendored contracts.",
              "3. If producer changes are intentional, cut a new producer release tag and update this repo's pin.",
              "",
              "### Drift report",
              "```",
              clippedReport.trimEnd(),
              "```",
              "",
              "_This issue is maintained automatically and will be updated on subsequent drift detections._"
            ].join("\n");
            body = bodyWithTamperWarning(body);

            // Find rolling issue:
            //  - Prefer ID marker identity
            //  - Fall back to scope marker, then exact title if markers got removed
            let found = await findRollingIssue("open");
            let existing = found.issue;
            let reopened = false;
            let foundBy = found.foundBy;
            let markersRepaired = false;
            let firstDetectedIso = null;
            let firstDetectedWasRepaired = false;

            if (!existing) {
              found = await findRollingIssue("closed");
              existing = found.issue;
              foundBy = found.foundBy;
              if (existing) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  state: "open"
                });
                reopened = true;
                core.info(`Reopened issue #${existing.number}`);
              }
            }

            if (!existing) {
              // Still not found: create it once.
              firstDetectedIso = now; // new unresolved period starts now
              const created = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: ISSUE_TITLE,
                body: upsertUniqueMarker(ensureFirstDetectedMarker(body, firstDetectedIso), "drift-ci-mode", "true"),
                labels: LABELS
              });
              existing = created.data;
              foundBy = "created";
              core.info(`Created issue: ${created.data.html_url}`);
            } else {
              // Determine first-detected time:
              // - If reopening (was closed), start a new unresolved period now.
              // - If already open, preserve existing marker; if missing, repair to now (tamper/self-heal).
              if (reopened) {
                firstDetectedIso = now;
              } else {
                firstDetectedIso = extractFirstDetectedIso(existing.body || "") || null;
                if (!firstDetectedIso) {
                  firstDetectedIso = now;
                  firstDetectedWasRepaired = true;
                }
              }

              // If found by fallback (title/scope), markers may be missing or partial.
              // Enforce dual markers (self-healing).
              let patchedBody = ensureDualMarkers(existing.body || "");
              patchedBody = ensureFirstDetectedMarker(patchedBody, firstDetectedIso);
              // Also ensure the tamper warning exists.
              patchedBody = bodyWithTamperWarning(patchedBody);
              patchedBody = upsertUniqueMarker(patchedBody, "drift-ci-mode", "true");
              if ((existing.body || "") !== patchedBody) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  body: patchedBody
                });
                core.info(`Enforced dual markers on issue #${existing.number} (found by: ${foundBy}).`);
                existing = { ...existing, body: patchedBody };
                // If we had to update the body, assume markers/warning were missing/edited.
                markersRepaired = true;
              }

              // Ensure title is set (optional cosmetic) while marker remains identity.
              // This is safe even if someone renamed it manually.
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  title: ISSUE_TITLE
                });
              } catch (e) {
                core.info(`Could not set title (non-fatal): ${e}`);
              }

              // Ensure labels exist on the rolling issue (non-fatal if labels are restricted).
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  labels: LABELS
                });
              } catch (e) {
                core.info(`Could not add labels (may be restricted): ${e}`);
              }
            }

            // Compute unresolved duration and inject into the body we'll publish.
            let durationStr = "unknown";
            let unresolvedMs = null;
            try {
              const fdMs = Date.parse(firstDetectedIso || "");
              const nowMs = Date.parse(now);
              if (!Number.isNaN(fdMs) && !Number.isNaN(nowMs)) {
                unresolvedMs = Math.max(0, nowMs - fdMs);
                durationStr = formatDuration(unresolvedMs);
              }
            } catch (e) {
              // keep "unknown"
            }

            // Drift budget enforcement (non-blocking escalation signal).
            const budgetHoursRaw = (process.env.DRIFT_BUDGET_HOURS || "").trim();
            const budgetHours = budgetHoursRaw ? Number(budgetHoursRaw) : 0;
            const budgetMs = (Number.isFinite(budgetHours) && budgetHours > 0) ? budgetHours * 3600 * 1000 : 0;
            const budgetBreached = !!(budgetMs && unresolvedMs !== null && unresolvedMs >= budgetMs);

            const budgetLabelsRaw = (process.env.DRIFT_BUDGET_LABELS || "").trim();
            const budgetLabels = budgetLabelsRaw
              ? budgetLabelsRaw.split(",").map(s => s.trim()).filter(Boolean)
              : [];

            const pingRaw = (process.env.DRIFT_BUDGET_PING || "").trim();
            const pingHandles = pingRaw
              ? pingRaw.split(",").map(s => s.trim().replace(/^@/, "")).filter(Boolean)
              : [];
            const pingLine = pingHandles.length ? pingHandles.map(h => `@${h}`).join(" ") : "";

            // Compute "time since last green" from drift-last-resolved marker if present.
            let lastResolvedIso = null;
            let sinceGreenStr = null;
            try {
              lastResolvedIso = extractLastResolvedIso(existing && existing.body ? existing.body : "");
              if (lastResolvedIso) {
                const lrMs = Date.parse(lastResolvedIso);
                const nowMs2 = Date.parse(now);
                if (!Number.isNaN(lrMs) && !Number.isNaN(nowMs2) && nowMs2 >= lrMs) {
                  sinceGreenStr = formatDuration(nowMs2 - lrMs);
                } else if (!Number.isNaN(lrMs) && !Number.isNaN(nowMs2) && nowMs2 < lrMs) {
                  // clock skew / edited marker; still surface iso
                  sinceGreenStr = "0s";
                }
              }
            } catch (e) {
              // leave nulls
            }
            const hasLastResolved = !!lastResolvedIso;

            // Previous resolved duration (from last green close), if present.
            // This is stable during an unresolved drift period and helps prioritize chronic/slow-to-fix drift.
            const prevResolvedAfterStr = extractLastDurationStr(
              existing && existing.body ? existing.body : ""
            );
            const hasPrevResolved = !!prevResolvedAfterStr;

            // Add lifecycle fields just below the header section.
            // We'll do this by inserting after the "## Contract parity drift detected" line.
            function injectDurationFields(bodyText) {
              const lines = (bodyText || "").split("\n");
              const idx = lines.findIndex(l => l.trim() === "## Contract parity drift detected");
              if (idx === -1) return bodyText;
              // Insert after the header and a blank line (header is followed by blank line currently).
              const insertAt = Math.min(idx + 2, lines.length);

              const fields = [
                `**First detected (UTC):** ${firstDetectedIso}`,
                `**Unresolved drift duration:** ${durationStr}`,
              ];

              // Only include last-resolved fields if marker exists.
              if (hasLastResolved) {
                fields.push(`**Last resolved (UTC):** ${lastResolvedIso}`);
                fields.push(`**Time since last green:** ${sinceGreenStr ?? "n/a"}`);
              }

              // Only include previous resolved duration if marker exists.
              if (hasPrevResolved) {
                fields.push(`**Previous resolved after:** ${prevResolvedAfterStr}`);
              }

              fields.push("");

              // Avoid duplicating if rerun: remove existing lifecycle lines first.
              const cleaned = lines.filter(l =>
                !l.startsWith("**First detected (UTC):**") &&
                !l.startsWith("**Unresolved drift duration:**") &&
                !l.startsWith("**Last resolved (UTC):**") &&
                !l.startsWith("**Time since last green:**") &&
                !l.startsWith("**Previous resolved after:**")
              );
              cleaned.splice(insertAt, 0, ...fields);
              return cleaned.join("\n");
            }

            body = ensureFirstDetectedMarker(body, firstDetectedIso);
            body = injectDurationFields(body);

            // If markers were repaired, leave a visible breadcrumb to discourage manual edits.
            if (markersRepaired || firstDetectedWasRepaired) {
              const tamperComment = [
                "‚ö†Ô∏è **Marker tamper detected and repaired**",
                "",
                "This rolling issue is located and managed by hidden HTML markers in the issue body.",
                "One or more identity markers (and/or first-detected marker) were missing or edited, so the observer workflow restored them automatically.",
                "",
                "Please avoid editing or removing the hidden markers at the top of the issue body.",
                `Workflow run: ${runUrl}`,
              ].join("\n");
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: tamperComment
              });
            }

            // If budget breached, add labels and a dedicated escalation comment.
            if (budgetBreached) {
              // Dedupe: one breach comment per unresolved period (firstDetectedIso).
              const BREACH_MARKER = "<!-- drift-budget-breached -->";
              const periodKey = firstDetectedIso || "unknown";
              const PERIOD_MARKER = `<!-- drift-budget-period: ${periodKey} -->`;

              async function alreadyCommentedForThisPeriod() {
                // Fetch recent comments (enough for typical issue activity).
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  per_page: 50,
                });
                return (comments || []).some(c => {
                  const b = c.body || "";
                  return b.includes(BREACH_MARKER) && b.includes(PERIOD_MARKER);
                });
              }

              const already = await alreadyCommentedForThisPeriod();

              // Pick an oncall assignee from .github/oncall_rotation.json.
              function pickOncallDecision(isoNow) {
                const isCI = ((process.env.CI || "").trim() === "true") || ((process.env.GITHUB_ACTIONS || "").trim() === "true");

                // Fixed assignee still supported for emergency overrides.
                const fixed = (process.env.DRIFT_ONCALL_ASSIGNEE || "").trim().replace(/^@/, "");
                if (fixed) {
                  if (isCI) {
                    throw new Error(
                      "DRIFT_ONCALL_ASSIGNEE override is forbidden in CI. " +
                      "Use governed .github/oncall_rotation.json rotation instead."
                    );
                  }
                  return {
                    assignee: fixed,
                    decision: { source: "env_fixed", assignee: fixed }
                  };
                }

                const path = ".github/oncall_rotation.json";
                if (!fs.existsSync(path)) {
                  throw new Error(`Oncall rotation file missing: ${path}`);
                }

                let cfg;
                try {
                  cfg = JSON.parse(fs.readFileSync(path, "utf8"));
                } catch (e) {
                  throw new Error(`Oncall rotation file is invalid JSON: ${path}: ${e}`);
                }

                const users = Array.isArray(cfg.rotation) ? cfg.rotation : [];
                const cleaned = users
                  .map(s => (typeof s === "string" ? s.trim().replace(/^@/, "") : ""))
                  .filter(Boolean);
                if (!cleaned.length) {
                  throw new Error(`Oncall rotation file has no valid users: ${path}`);
                }

                const t = Date.parse(isoNow);
                if (Number.isNaN(t)) {
                  throw new Error(`Oncall selection failed: could not parse ISO timestamp: ${isoNow}`);
                }

                // Compute today's UTC date as YYYY-MM-DD for exception matching.
                function utcYmd(ms) {
                  const d = new Date(ms);
                  const y = d.getUTCFullYear();
                  const m = String(d.getUTCMonth() + 1).padStart(2, "0");
                  const day = String(d.getUTCDate()).padStart(2, "0");
                  return `${y}-${m}-${day}`;
                }
                const today = utcYmd(t);

                // Exception override (vacations/coverage). Ranges inclusive.
                // Tie-break: priority (lower wins) ‚Üí shortest range ‚Üí earliest start ‚Üí file order.
                const exceptions = Array.isArray(cfg.exceptions) ? cfg.exceptions : [];
                const candidates = [];
                for (let idx = 0; idx < exceptions.length; idx++) {
                  const e = exceptions[idx];
                  if (!e || typeof e !== "object") continue;
                  const start = typeof e.start === "string" ? e.start.trim() : "";
                  const end = typeof e.end === "string" ? e.end.trim() : "";
                  const assignee = typeof e.assignee === "string" ? e.assignee.trim().replace(/^@/, "") : "";
                  const priorityRaw = (typeof e.priority === "number" && Number.isFinite(e.priority))
                    ? Math.trunc(e.priority)
                    : 1000;
                  const reason = typeof e.reason === "string" ? e.reason.trim() : "";
                  if (!start || !end || !assignee) continue;
                  if (today < start || today > end) continue;

                  const sMs = Date.parse(`${start}T00:00:00Z`);
                  const eMs = Date.parse(`${end}T00:00:00Z`);
                  if (Number.isNaN(sMs) || Number.isNaN(eMs) || eMs < sMs) continue;
                  const days = Math.floor((eMs - sMs) / 86400000) + 1;

                  candidates.push({ start, end, assignee, days, idx, priority: priorityRaw, reason });
                }

                if (candidates.length) {
                  candidates.sort((a, b) => {
                    // 1) explicit priority wins (lower is higher priority)
                    if (a.priority !== b.priority) return a.priority - b.priority;
                    // 2) shortest range wins
                    if (a.days !== b.days) return a.days - b.days;
                    // 3) earliest start wins
                    if (a.start !== b.start) return a.start < b.start ? -1 : 1;
                    // 4) file order wins
                    return a.idx - b.idx;
                  });
                  const chosen = candidates[0];
                  return {
                    assignee: chosen.assignee,
                    decision: {
                      source: "exception",
                      today,
                      exception: {
                        start: chosen.start,
                        end: chosen.end,
                        priority: chosen.priority,
                        days: chosen.days,
                        reason: chosen.reason || null,
                        file_index: chosen.idx
                      },
                      assignee: chosen.assignee
                    }
                  };
                }

                const strategy = (cfg.strategy || "daily").toString().toLowerCase();
                if (strategy !== "daily" && strategy !== "weekly") {
                  throw new Error(`Oncall rotation: unsupported strategy '${strategy}' (expected 'daily' or 'weekly')`);
                }

                // Deterministic daily rotation by UTC day index.
                function pickDaily(ms) {
                  const dayIndex = Math.floor(ms / 86400000);
                  const assignee = cleaned[dayIndex % cleaned.length];
                  return {
                    assignee,
                    decision: {
                      source: "rotation",
                      strategy: "daily",
                      today,
                      dayIndex,
                      rotation_size: cleaned.length,
                      assignee
                    }
                  };
                }

                // Deterministic weekly rotation by week bucket with configurable week_start.
                function pickWeekly(ms) {
                  const weekStartRaw = (cfg.week_start || "monday").toString().toLowerCase();
                  const allowed = new Set(["sunday","monday","tuesday","wednesday","thursday","friday","saturday"]);
                  if (!allowed.has(weekStartRaw)) {
                    throw new Error(`Oncall rotation: unsupported week_start '${weekStartRaw}' (expected one of ${[...allowed].join(", ")})`);
                  }
                  const map = {
                    sunday: 0, monday: 1, tuesday: 2, wednesday: 3,
                    thursday: 4, friday: 5, saturday: 6
                  };
                  const desired = map[weekStartRaw];

                  const d = new Date(ms);
                  const dow = d.getUTCDay();
                  const delta = (dow - desired + 7) % 7;

                  const midnight = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
                  const weekStartMidnight = midnight - delta * 86400000;

                  const weekIndex = Math.floor(weekStartMidnight / (7 * 86400000));
                  const assignee = cleaned[weekIndex % cleaned.length];
                  return {
                    assignee,
                    decision: {
                      source: "rotation",
                      strategy: "weekly",
                      week_start: weekStartRaw,
                      today,
                      weekIndex,
                      rotation_size: cleaned.length,
                      assignee
                    }
                  };
                }

                if (strategy === "weekly") return pickWeekly(t);
                return pickDaily(t);
              }

              function formatDecision(dec) {
                if (!dec) return "_(no decision data)_";
                const lines = [];
                lines.push("Rotation decision:");

                // Provenance (stable audit linkage)
                lines.push(`- Rotation config sha256: ${rotationSha256}${rotationShaShort ? ` (${rotationShaShort})` : ""}`);
                lines.push(`- Rotation manifest: ${ROTATION_MANIFEST_PATH}`);
                lines.push(`- Rotation schema sha256: ${schemaSha256}${schemaShaShort ? ` (${schemaShaShort})` : ""}`);
                lines.push(`- Rotation schema manifest: ${ROTATION_SCHEMA_MANIFEST_PATH}`);

                if (rotationSchemaVersion) {
                  lines.push(`- Rotation schema_version: ${rotationSchemaVersion}`);
                }

                if (dec.source) lines.push(`- Source: ${dec.source}`);
                if (dec.today) lines.push(`- Today (UTC): ${dec.today}`);
                if (dec.strategy) lines.push(`- Strategy: ${dec.strategy}`);
                if (dec.week_start) lines.push(`- Week start: ${dec.week_start}`);
                if (typeof dec.dayIndex === "number") lines.push(`- Day index: ${dec.dayIndex}`);
                if (typeof dec.weekIndex === "number") lines.push(`- Week index: ${dec.weekIndex}`);
                if (typeof dec.rotation_size === "number") lines.push(`- Rotation size: ${dec.rotation_size}`);
                if (dec.exception) {
                  lines.push("- Exception matched: yes");
                  lines.push(`  - Range: ${dec.exception.start} ‚Üí ${dec.exception.end} (${dec.exception.days}d)`);
                  lines.push(`  - Priority: ${dec.exception.priority}`);
                  if (dec.exception.reason) lines.push(`  - Reason: ${dec.exception.reason}`);
                  lines.push(`  - File index: ${dec.exception.file_index}`);
                } else {
                  if (dec.source === "rotation") lines.push("- Exception matched: no");
                }
                if (dec.assignee) lines.push(`- Final assignee: @${dec.assignee}`);
                return lines.join("\n");
              }

              // Add issue to GitHub Projects v2 (optional).
              async function addIssueToProjectV2(projectNodeId, issueNodeId) {
                const mutation = `
                  mutation($projectId: ID!, $contentId: ID!) {
                    addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                      item { id }
                    }
                  }
                `;
                return await github.graphql(mutation, {
                  projectId: projectNodeId,
                  contentId: issueNodeId
                });
              }

              try {
                if (budgetLabels.length) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existing.number,
                    labels: budgetLabels
                  });
                }
              } catch (e) {
                core.info(`Could not add budget labels (non-fatal): ${e}`);
              }

              if (!already) {
                // Strong operator experience: assign oncall + add to project once per period.
                const picked = assertOncallDecision(pickOncallDecision(now));
                const oncall = picked.assignee;
                const oncallDecision = picked.decision;

                let assignedOncall = null;
                let decisionBlockForComment = null;

                try {
                    const triagedLabel = (process.env.DRIFT_TRIAGED_LABEL || "triaged").trim() || "triaged";
                    const needsOncallLabel = (process.env.DRIFT_NEEDS_ONCALL_LABEL || "needs-oncall").trim() || "needs-oncall";
                    const oncallAssignedLabel = (process.env.DRIFT_ONCALL_ASSIGNED_LABEL || "oncall-assigned").trim() || "oncall-assigned";

                    // Don't overwrite existing assignees (manual triage wins).
                    const issueResp = await github.rest.issues.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: existing.number
                    });
                    const currentAssignees = (issueResp.data.assignees || []).map(a => a.login);
                    const currentLabels = (issueResp.data.labels || [])
                      .map(l => typeof l === "string" ? l : (l.name || ""))
                      .filter(Boolean);

                    const hasTriaged = currentLabels.includes(triagedLabel);
                    const hasNeedsOncall = currentLabels.includes(needsOncallLabel);

                    // Tight policy:
                    // - Only assign if no assignees AND (NOT triaged OR needs-oncall override).
                    // - If triaged and no override, skip.
                    const shouldAssign =
                      currentAssignees.length === 0 &&
                      (!hasTriaged || hasNeedsOncall);

                    if (shouldAssign) {
                      await github.rest.issues.addAssignees({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: existing.number,
                        assignees: [oncall]
                      });
                      core.info(`Assigned oncall: @${oncall}`);
                      assignedOncall = oncall;

                      const DECISION_MARKER = "<!-- drift-oncall-decision -->";
                      decisionBlockForComment = `${DECISION_MARKER}\n\`\`\`text\n${formatDecision(oncallDecision)}\n\`\`\``;

                      // Label to indicate automation assignment occurred.
                      try {
                        await github.rest.issues.addLabels({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: existing.number,
                          labels: [oncallAssignedLabel]
                        });
                      } catch (e) {
                        core.info(`Could not add ${oncallAssignedLabel} label (non-fatal): ${e}`);
                      }

                      // If needs-oncall was present (override), clear it after assignment.
                      if (hasNeedsOncall) {
                        try {
                          await github.rest.issues.removeLabel({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: existing.number,
                            name: needsOncallLabel
                          });
                        } catch (e) {
                          core.info(`Could not remove ${needsOncallLabel} label (non-fatal): ${e}`);
                        }
                      }
                    } else {
                      const reasons = [];
                      if (currentAssignees.length !== 0) reasons.push(`assignees present (${currentAssignees.join(", ")})`);
                      if (hasTriaged && !hasNeedsOncall) reasons.push(`${triagedLabel} label present (no ${needsOncallLabel} override)`);
                      core.info(`Skipping oncall assignment; ${reasons.join(" + ")}`);
                    }
                } catch (e) {
                  core.info(`Could not assign oncall (non-fatal): ${e}`);
                }
                // Post the (deduped) escalation comment once per period, including the oncall decision if any.
                const escalationLines = [
                  BREACH_MARKER,
                  PERIOD_MARKER,
                  "",
                  "üö® **Drift budget breached**",
                  "",
                  `Unresolved drift has exceeded the budget of **${budgetHours}h**.`,
                  `**Current unresolved duration:** ${durationStr}`,
                  rotationShaShort ? `**Rotation config:** ${rotationShaShort}` : "",
                  schemaShaShort ? `**Rotation schema:** ${schemaShaShort}` : "",
                  "",
                  pingLine ? `Paging: ${pingLine}` : "(No DRIFT_BUDGET_PING configured.)",
                  assignedOncall ? `Assigned oncall: @${assignedOncall}` : "",
                  decisionBlockForComment || "",
                  "",
                  `Workflow run: ${runUrl}`,
                ].filter(Boolean);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  body: escalationLines.join("\n")
                });

                const projectId = (process.env.DRIFT_PROJECT_NODE_ID || "").trim();
                if (projectId) {
                  try {
                    // Reuse the fetched issue if available; otherwise fetch.
                    const issueNodeId = (typeof issueResp !== "undefined" && issueResp.data && issueResp.data.node_id)
                      ? issueResp.data.node_id
                      : (await github.rest.issues.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: existing.number
                        })).data.node_id;
                    await addIssueToProjectV2(projectId, issueNodeId);
                    core.info(`Added issue #${existing.number} to ProjectV2 ${projectId}`);
                  } catch (e) {
                    core.info(`Could not add to ProjectV2 (non-fatal): ${e}`);
                  }
                } else {
                  core.info("No project configured (DRIFT_PROJECT_NODE_ID).");
                }
              } else {
                core.info(`Budget breach already recorded for this period (${periodKey}); skipping comment.`);
              }
            }

            // Update body (keeps latest report visible)
            // Stamp CI mode for provenance (hidden marker).
            const bodyWithCiMarker = upsertUniqueMarker(body, "drift-ci-mode", "true");
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: bodyWithCiMarker
            });

            // Add comment (keeps a timeline of drift detections)
            const comment = [
              reopened ? `üîÑ Drift detected again (issue reopened) at **${now}**.` : `Drift detected again at **${now}**.`,
              `Workflow run: ${runUrl}`,
              "",
              `_Rolling issue identity: dual-marker (fallback used: ${foundBy})._`,
              `**Unresolved drift duration:** ${durationStr}`,
              budgetBreached ? `üö® **Budget breached:** ${budgetHours}h` : "",
              "",
              "```",
              clippedReport.trimEnd(),
              "```"
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            core.info(`Updated and commented on issue #${existing.number}`);

      - name: Auto-close rolling drift issue when parity returns to green
        if: steps.parity.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            // Defense in depth: require explicit CI=true inside the green-path script.
            const ciVal = (process.env.CI || "").trim();
            if (ciVal !== "true") {
              throw new Error(
                `Observer green-path script must run with CI=true explicitly (got CI='${ciVal || "(unset)"}').`
              );
            }

            const ISSUE_TITLE = "Upstream contract drift detected";
            const SCOPE_MARKER = "<!-- drift-rolling-issue: contracts -->";
            const ID_MARKER = "<!-- drift-rolling-issue-id: contracts:9d3f1a2c -->";
            const LAST_RESOLVED_PREFIX = "<!-- drift-last-resolved: ";
            const LAST_DURATION_PREFIX = "<!-- drift-last-duration: ";
            const TAMPER_NOTE = "> \u26a0\ufe0f **Automation identity markers**: Do not remove or edit the hidden HTML markers at the top of this issue body. They are used to locate, reopen, and update this rolling issue automatically.\n";
            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchOne(query) {
              const res = await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 10
              });
              return res.data.items || [];
            }

            function hasBothMarkers(body) {
              const b = body || "";
              return b.includes(SCOPE_MARKER) && b.includes(ID_MARKER);
            }
            function ensureDualMarkers(body) {
              const b = (body || "").trimStart();
              if (hasBothMarkers(b)) return b;
              const cleaned = b
                .replaceAll(SCOPE_MARKER, "")
                .replaceAll(ID_MARKER, "")
                .trimStart();
              return `${SCOPE_MARKER}\n${ID_MARKER}\n\n${cleaned}`;
            }

            function ensureLastResolvedMarker(body, iso) {
              const b = body || "";
              const markerLine = `<!-- drift-last-resolved: ${iso} -->`;
              if (b.includes("<!-- drift-last-resolved:")) {
                return b.replace(/<!--\s*drift-last-resolved:\s*([0-9T:\.\-Z]+)\s*-->/, markerLine);
              }
              const lines = b.split("\n");
              // Insert after ID marker (line 1) by default.
              if (lines.length >= 2 && lines[0].includes("drift-rolling-issue") && lines[1].includes("drift-rolling-issue-id")) {
                // If there's also a first-detected marker on line 2, insert after it.
                const fdIdx = lines.findIndex(l => l.includes("<!-- drift-first-detected:"));
                if (fdIdx !== -1) {
                  lines.splice(fdIdx + 1, 0, markerLine);
                } else {
                  lines.splice(2, 0, markerLine);
                }
                return lines.join("\n");
              }
              return `${SCOPE_MARKER}\n${ID_MARKER}\n${markerLine}\n\n${b.trimStart()}`;
            }

            // Remove ALL instances of a given marker key (even if duplicates exist).
            function stripAllMarkers(bodyText, key) {
              const body = (bodyText || "");
              const re = new RegExp(`^\\s*<!--\\s*${key}:\\s*[^>]*-->\\s*$`, "gm");
              const stripped = body.replace(re, "").replace(/\n{3,}/g, "\n\n");
              return stripped.trimEnd() + "\n";
            }

            // Insert exactly ONE marker in a canonical position.
            function upsertUniqueMarker(bodyText, key, value) {
              const marker = `<!-- ${key}: ${value} -->`;
              const cleaned = stripAllMarkers(bodyText, key);
              const lines = cleaned.split("\n");
              const idIdx = lines.findIndex(l => l.includes("drift-rolling-issue"));
              const insertAt = idIdx >= 0 ? idIdx + 1 : 0;
              if (lines.length === 1 && lines[0] === "") {
                return marker + "\n";
              }
              lines.splice(insertAt, 0, marker);
              return lines.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd() + "\n";
            }

            // Ensure marker lines are unique within a comment payload.
            function uniqueMarkerLines(lines) {
              const seen = new Set();
              const out = [];
              for (const l of (lines || [])) {
                if (typeof l !== "string") continue;
                const s = l.trimEnd();
                if (!s) { out.push(l); continue; }
                if (s.startsWith("<!--") && s.endsWith("-->")) {
                  if (seen.has(s)) continue;
                  seen.add(s);
                }
                out.push(l);
              }
              return out;
            }

            function formatDuration(ms) {
              const totalSec = Math.max(0, Math.floor(ms / 1000));
              const days = Math.floor(totalSec / 86400);
              const hours = Math.floor((totalSec % 86400) / 3600);
              const mins = Math.floor((totalSec % 3600) / 60);
              const secs = totalSec % 60;
              const parts = [];
              if (days) parts.push(`${days}d`);
              if (days || hours) parts.push(`${hours}h`);
              if (days || hours || mins) parts.push(`${mins}m`);
              parts.push(`${secs}s`);
              return parts.join(" ");
            }

            function bodyWithTamperWarning(bodyText) {
              if ((bodyText || "").includes("Automation identity markers")) return bodyText;
              const lines = (bodyText || "").split("\n");
              lines.splice(3, 0, TAMPER_NOTE.trimEnd(), "");
              return lines.join("\n");
            }

            function extractFirstDetectedIso(body) {
              const b = body || "";
              const re = /<!--\s*drift-first-detected:\s*([0-9T:\.\-Z]+)\s*-->/;
              const m = b.match(re);
              return m ? m[1] : null;
            }

            // Prefer ID-marker identity; fall back to scope-marker, then exact title.
            let foundBy = "id_marker";
            let items = await searchOne(`${repoQ} is:issue in:body "${ID_MARKER}" is:open`);
            let existing = items.find(i => (i.body || "").includes(ID_MARKER)) || null;

            if (!existing) {
              foundBy = "scope_marker";
              items = await searchOne(`${repoQ} is:issue in:body "${SCOPE_MARKER}" is:open`);
              existing = items.find(i => (i.body || "").includes(SCOPE_MARKER)) || null;
            }

            if (!existing) {
              foundBy = "title";
              items = await searchOne(`${repoQ} is:issue in:title "${ISSUE_TITLE}" is:open`);
              existing = items.find(i => i.title === ISSUE_TITLE) || null;
            }

            if (!existing) {
              core.info("No open drift issue found; nothing to close.");
              return;
            }

            // Enforce markers (self-healing) before closing, stamp last-resolved,
            // and surface last-resolved fields in the visible body.
            let patchedBody = ensureDualMarkers(existing.body || "");
            patchedBody = ensureLastResolvedMarker(patchedBody, now);
            patchedBody = bodyWithTamperWarning(patchedBody);

            // Compute "Resolved after" duration using first-detected -> now, if first-detected exists.
            const firstDetectedIso = extractFirstDetectedIso(patchedBody) || null;
            let resolvedAfterStr = "n/a";
            if (firstDetectedIso) {
              const fdMs = Date.parse(firstDetectedIso);
              const nowMs = Date.parse(now);
              if (!Number.isNaN(fdMs) && !Number.isNaN(nowMs) && nowMs >= fdMs) {
                resolvedAfterStr = formatDuration(nowMs - fdMs);
              } else if (!Number.isNaN(fdMs) && !Number.isNaN(nowMs) && nowMs < fdMs) {
                resolvedAfterStr = "0s";
              }
            }

            // Stamp last-duration marker (even if n/a, it's still explicit and stable).
            patchedBody = ensureLastDurationMarker(patchedBody, resolvedAfterStr);

            // Inject/refresh header-visible fields:
            // - keep existing first-detected if present
            // - set last-resolved to now
            // - set time since last green to 0s
            function injectLifecycleFields(bodyText) {
              const lines = (bodyText || "").split("\n");
              const idx = lines.findIndex(l => l.trim() === "## Contract parity drift detected");
              if (idx === -1) return bodyText;

              // Remove existing lifecycle lines (idempotent).
              const cleaned = lines.filter(l =>
                !l.startsWith("**First detected (UTC):**") &&
                !l.startsWith("**Unresolved drift duration:**") &&
                !l.startsWith("**Last resolved (UTC):**") &&
                !l.startsWith("**Time since last green:**") &&
                !l.startsWith("**Resolved after:**")
              );

              const fdIso = extractFirstDetectedIso(bodyText);
              const hasFirstDetected = !!fdIso;
              // On green, we always stamp last-resolved = now, but keep this conditional to avoid weird states.
              const hasLastResolved = !!now;

              const fields = [];

              // Only show first-detected-derived fields if marker exists.
              if (hasFirstDetected) {
                fields.push(`**First detected (UTC):** ${fdIso}`);
                fields.push(`**Unresolved drift duration:** n/a`);
                fields.push(`**Resolved after:** ${resolvedAfterStr}`);
              }

              // Always show last-resolved fields on green (we stamp them), but still guarded.
              if (hasLastResolved) {
                fields.push(`**Last resolved (UTC):** ${now}`);
                fields.push(`**Time since last green:** 0s`);
              }

              fields.push("");

              const insertAt = Math.min(idx + 2, cleaned.length);
              cleaned.splice(insertAt, 0, ...fields);
              return cleaned.join("\n");
            }

            patchedBody = injectLifecycleFields(patchedBody);
            patchedBody = upsertUniqueMarker(patchedBody, "drift-ci-mode", "true");

            if ((existing.body || "") !== patchedBody) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: patchedBody
              });
              core.info(`Enforced dual markers on issue #${existing.number} during auto-close (found by: ${foundBy}).`);

              // Leave a tamper warning comment if we had to repair body markers/warning.
              const tamperComment = [
                "\u26a0\ufe0f **Marker tamper detected and repaired**",
                "",
                "This rolling issue is located and managed by hidden HTML markers in the issue body.",
                "One or more identity markers and/or lifecycle markers were missing or edited, so the observer workflow restored them automatically.",
                "",
                "Please avoid editing or removing the hidden markers at the top of the issue body.",
                `Workflow run: ${runUrl}`,
              ].join("\n");
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: tamperComment
              });
            }

            // Comment "Resolved" with context and CI provenance markers.
            const CI_MARKER = "<!-- drift-ci-mode: true -->";
            const RESOLVED_MARKER = "<!-- drift-event: resolved -->";
            const RESOLVED_PERIOD_MARKER = firstDetectedIso
              ? `<!-- drift-resolved-for-period: ${firstDetectedIso} -->`
              : null;
            const RESOLVED_FOR_PERIOD_RE = /<!--\s*drift-resolved-for-period:\s*([^>]+)\s*-->/;

            // Dedupe: only one resolved comment per drift episode (keyed by firstDetectedIso).
            // Scans newest‚Üíoldest pages, stops once comments are older than firstDetectedIso.
            async function alreadyResolvedForThisPeriod() {
              if (!RESOLVED_PERIOD_MARKER) return false;
              const PER_PAGE = 100; // GitHub max
              const MAX_PAGES = 50; // hard cap (up to 5 000 comments worst-case)

              const cutoff = Date.parse(firstDetectedIso);
              if (Number.isNaN(cutoff)) {
                throw new Error(`Invalid firstDetectedIso (cannot parse): ${firstDetectedIso}`);
              }

              // Use comment count from the search result to jump to the last page.
              const totalComments = typeof existing.comments === "number" ? existing.comments : 0;
              let startPage = Math.max(1, Math.floor((Math.max(0, totalComments - 1)) / PER_PAGE) + 1);

              let pagesScanned = 0;
              for (let page = startPage; page >= 1; page--) {
                pagesScanned++;
                if (pagesScanned > MAX_PAGES) {
                  core.info(`Resolved dedupe scan hit MAX_PAGES=${MAX_PAGES}; assuming resolved comment may already exist.`);
                  return true; // fail-safe: prevent spam
                }

                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  per_page: PER_PAGE,
                  page
                });

                const items = comments || [];
                if (!items.length) {
                  // Empty page while scanning backwards ‚Äî continue (rare).
                  continue;
                }

                // Items are oldest‚Üínewest within the page.
                const newest = items[items.length - 1];
                const newestTs = Date.parse(newest.created_at || "");
                if (!Number.isNaN(newestTs) && newestTs < cutoff) {
                  // Entire page is older than cutoff ‚Üí earlier pages are even older.
                  return false;
                }

                // Scan comments newest‚Üíoldest within the page for correct boundary detection.
                for (let i = items.length - 1; i >= 0; i--) {
                  const c = items[i];
                  const ts = Date.parse(c.created_at || "");
                  if (!Number.isNaN(ts) && ts < cutoff) continue;
                  const b = c.body || "";

                  // Episode boundary: if we encounter *any* drift-resolved-for-period
                  // marker for a DIFFERENT period, we've crossed into an older episode.
                  // Since we scan newest‚Üíoldest, this is the first such boundary ‚Üí safe to stop.
                  const pm = b.match(RESOLVED_FOR_PERIOD_RE);
                  if (pm) {
                    const seenPeriod = (pm[1] || "").trim();
                    if (seenPeriod && seenPeriod !== firstDetectedIso) {
                      return false;
                    }
                  }

                  // Dedupe condition for current period: period marker alone is authoritative.
                  // This prevents spam even if other markers/text are edited or omitted.
                  if (b.includes(RESOLVED_PERIOD_MARKER)) {
                    return true;
                  }
                }
              }

              return false;
            }

            const already = await alreadyResolvedForThisPeriod();

            const comment = uniqueMarkerLines([
              CI_MARKER,
              RESOLVED_MARKER,
              RESOLVED_PERIOD_MARKER,
              "",
              `‚úÖ Resolved at **${now}**.`,
              `Parity is green against upstream \`main\`.`,
              resolvedAfterStr ? `Resolved after: ${resolvedAfterStr}` : "",
              `Workflow run: ${runUrl}`,
              "",
              "If drift reappears, this issue will be reopened automatically by the observer.",
              "",
              `_Rolling issue identity: dual-marker (fallback used: ${foundBy})._`
            ]).filter(Boolean).join("\n");

            if (!already) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: comment
              });
            } else {
              core.info(`Resolved comment already exists for period ${firstDetectedIso}; skipping.`);
            }

            // Close the issue.
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              state: "closed"
            });

            core.info(`Closed drift issue #${existing.number}`);

      - name: Summary
        if: always()
        run: |
          echo "Observer workflow complete."
          if [[ "${{ steps.parity.outcome }}" == "failure" ]]; then
            echo "Parity failed: drift issue opened/updated."
          else
            echo "Parity OK: drift issue (if any) auto-closed."
          fi
