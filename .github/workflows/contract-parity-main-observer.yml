name: contract-parity-main-observer

on:
  # Nightly drift detector against upstream main (non-blocking observer).
  schedule:
    - cron: "17 3 * * *" # 03:17 UTC daily
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write

jobs:
  parity-observer:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Check parity against upstream main (observer)
        id: parity
        env:
          UPSTREAM_REF: main
          CHECK_RULE_REGISTRY: "1"
          CHECK_INTERNAL_RULES: "1"
          # If you added bundle support and want to use it here, keep default USE_CONTRACTS_BUNDLE=1.
          # USE_CONTRACTS_BUNDLE: "1"
        shell: bash
        run: |
          set -euo pipefail

          echo "Running contract parity against upstream: ${UPSTREAM_REF}"
          echo ""

          # Capture output for issue body + artifact.
          # Do not let failure stop the job (continue-on-error is job-level).
          python ci/check_upstream_contracts.py 2>&1 | tee drift_report.txt

      - name: Upload drift report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: contract-parity-main-observer-report
          path: drift_report.txt

      - name: Open or update rolling drift issue
        if: steps.parity.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const ISSUE_TITLE = "Upstream contract drift detected";
            const LABELS = ["contracts", "drift", "automation"];
            const MARKER = "<!-- drift-rolling-issue: contracts -->";

            const reportPath = "drift_report.txt";
            const report = fs.existsSync(reportPath)
              ? fs.readFileSync(reportPath, 'utf8')
              : "(No drift report output found.)";

            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            // Keep issue bodies readable: trim extremely long logs but preserve the most useful tail.
            const MAX_CHARS = 60000;
            let clippedReport = report;
            if (clippedReport.length > MAX_CHARS) {
              clippedReport = clippedReport.slice(0, 15000)
                + "\n\n... (truncated) ...\n\n"
                + clippedReport.slice(-35000);
            }

            // IMPORTANT: Embed immutable marker at top of body so we can find/reopen/update
            // the same rolling issue reliably via Search API (not title matching).
            const body = [
              MARKER,
              "",
              "## Contract parity drift detected",
              "",
              `**Time (UTC):** ${now}`,
              `**Workflow run:** ${runUrl}`,
              "",
              "This repository vendors contract artifacts from the producer repo. The nightly observer checks parity against upstream `main` and detected drift.",
              "",
              "### Next actions",
              "1. Review the drift report below.",
              "2. Decide whether to update the pinned `UPSTREAM_REF` tag (preferred) or sync vendored contracts.",
              "3. If producer changes are intentional, cut a new producer release tag and update this repo's pin.",
              "",
              "### Drift report",
              "```",
              clippedReport.trimEnd(),
              "```",
              "",
              "_This issue is maintained automatically and will be updated on subsequent drift detections._"
            ].join("\n");

            // Use GitHub Search API to find the rolling issue by immutable marker (not title).
            // Strategy:
            //  1) search open issues containing MARKER in body
            //  2) else search closed issues containing MARKER in body and reopen
            //  3) else create once (with MARKER)
            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchByMarker(state) {
              const q = `${repoQ} is:issue in:body "${MARKER}" is:${state}`;
              const res = await github.rest.search.issuesAndPullRequests({
                q,
                per_page: 5
              });
              const items = res.data.items || [];
              // Marker search is already very specific; still ensure the marker is actually present.
              return items.find(i => (i.body || "").includes(MARKER)) || null;
            }

            let existing = await searchByMarker("open");
            let reopened = false;

            if (!existing) {
              existing = await searchByMarker("closed");
              if (existing) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  state: "open"
                });
                reopened = true;
                core.info(`Reopened issue #${existing.number}`);
              }
            }

            if (!existing) {
              // Still not found: create it once.
              const created = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: ISSUE_TITLE,
                body,
                labels: LABELS
              });
              existing = created.data;
              core.info(`Created issue: ${created.data.html_url}`);
            } else {
              // Ensure title is set (optional cosmetic) while marker remains identity.
              // This is safe even if someone renamed it manually.
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  title: ISSUE_TITLE
                });
              } catch (e) {
                core.info(`Could not set title (non-fatal): ${e}`);
              }

              // Ensure labels exist on the rolling issue (non-fatal if labels are restricted).
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  labels: LABELS
                });
              } catch (e) {
                core.info(`Could not add labels (may be restricted): ${e}`);
              }
            }

            // Update body (keeps latest report visible)
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body
            });

            // Add comment (keeps a timeline of drift detections)
            const comment = [
              reopened ? `ðŸ”„ Drift detected again (issue reopened) at **${now}**.` : `Drift detected again at **${now}**.`,
              `Workflow run: ${runUrl}`,
              "",
              "_Rolling issue identity is marker-based._",
              "",
              "```",
              clippedReport.trimEnd(),
              "```"
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            core.info(`Updated and commented on issue #${existing.number}`);

      - name: Auto-close rolling drift issue when parity returns to green
        if: steps.parity.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const ISSUE_TITLE = "Upstream contract drift detected";
            const MARKER = "<!-- drift-rolling-issue: contracts -->";
            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            // Find existing open rolling issue by immutable marker (not title).
            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;
            const q = `${repoQ} is:issue in:body "${MARKER}" is:open`;
            const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
            const items = res.data.items || [];
            const existing = items.find(i => (i.body || "").includes(MARKER)) || null;

            if (!existing) {
              core.info("No open drift issue found; nothing to close.");
              return;
            }

            // Comment "Resolved" with context.
            const comment = [
              `âœ… Resolved at **${now}**.`,
              `Parity is green against upstream \`main\`.`,
              `Workflow run: ${runUrl}`,
              "",
              "If drift reappears, this issue will be reopened automatically by the observer.",
              "",
              "_Rolling issue identity is marker-based._"
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            // Close the issue.
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              state: "closed"
            });

            core.info(`Closed drift issue #${existing.number}`);

      - name: Summary
        if: always()
        run: |
          echo "Observer workflow complete."
          if [[ "${{ steps.parity.outcome }}" == "failure" ]]; then
            echo "Parity failed: drift issue opened/updated."
          else
            echo "Parity OK: drift issue (if any) auto-closed."
          fi
