name: contract-parity-main-observer

on:
  # Nightly drift detector against upstream main (non-blocking observer).
  schedule:
    - cron: "17 3 * * *" # 03:17 UTC daily
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write

jobs:
  parity-observer:
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Check parity against upstream main (observer)
        id: parity
        env:
          UPSTREAM_REF: main
          CHECK_RULE_REGISTRY: "1"
          CHECK_INTERNAL_RULES: "1"
          # If you added bundle support and want to use it here, keep default USE_CONTRACTS_BUNDLE=1.
          # USE_CONTRACTS_BUNDLE: "1"
        shell: bash
        run: |
          set -euo pipefail

          echo "Running contract parity against upstream: ${UPSTREAM_REF}"
          echo ""

          # Capture output for issue body + artifact.
          # Do not let failure stop the job (continue-on-error is job-level).
          python ci/check_upstream_contracts.py 2>&1 | tee drift_report.txt

      - name: Upload drift report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: contract-parity-main-observer-report
          path: drift_report.txt

      - name: Open or update rolling drift issue
        if: steps.parity.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const ISSUE_TITLE = "Upstream contract drift detected";
            const LABELS = ["contracts", "drift", "automation"];
            // Dual-marker hardening:
            //  - SCOPE_MARKER is human-readable category
            //  - ID_MARKER is the canonical identity (search key)
            const SCOPE_MARKER = "<!-- drift-rolling-issue: contracts -->";
            const ID_MARKER = "<!-- drift-rolling-issue-id: contracts:9d3f1a2c -->";

            const reportPath = "drift_report.txt";
            const report = fs.existsSync(reportPath)
              ? fs.readFileSync(reportPath, 'utf8')
              : "(No drift report output found.)";

            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            // Keep issue bodies readable: trim extremely long logs but preserve the most useful tail.
            const MAX_CHARS = 60000;
            let clippedReport = report;
            if (clippedReport.length > MAX_CHARS) {
              clippedReport = clippedReport.slice(0, 15000)
                + "\n\n... (truncated) ...\n\n"
                + clippedReport.slice(-35000);
            }

            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchOne(query) {
              const res = await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 10
              });
              return res.data.items || [];
            }

            function hasBothMarkers(body) {
              const b = body || "";
              return b.includes(SCOPE_MARKER) && b.includes(ID_MARKER);
            }

            function ensureDualMarkers(body) {
              const b = (body || "").trimStart();
              // Place markers at the very top, stable order.
              // If either is missing, prepend both (idempotent if already present).
              if (hasBothMarkers(b)) return b;
              // Remove any single/partial marker occurrences to avoid duplicates.
              const cleaned = b
                .replaceAll(SCOPE_MARKER, "")
                .replaceAll(ID_MARKER, "")
                .trimStart();
              return `${SCOPE_MARKER}\n${ID_MARKER}\n\n${cleaned}`;
            }

            async function findRollingIssue(state) {
              // 1) ID-marker search (canonical identity)
              const byIdQ = `${repoQ} is:issue in:body "${ID_MARKER}" is:${state}`;
              const idItems = await searchOne(byIdQ);
              const idHit = idItems.find(i => (i.body || "").includes(ID_MARKER)) || null;
              if (idHit) return { issue: idHit, foundBy: "id_marker" };

              // 2) Scope-marker fallback (older identity)
              const byScopeQ = `${repoQ} is:issue in:body "${SCOPE_MARKER}" is:${state}`;
              const scopeItems = await searchOne(byScopeQ);
              const scopeHit = scopeItems.find(i => (i.body || "").includes(SCOPE_MARKER)) || null;
              if (scopeHit) return { issue: scopeHit, foundBy: "scope_marker" };

              // 3) Title-based fallback (exact title) in case markers were removed
              const byTitleQ = `${repoQ} is:issue in:title "${ISSUE_TITLE}" is:${state}`;
              const titleItems = await searchOne(byTitleQ);
              const titleHit = titleItems.find(i => i.title === ISSUE_TITLE) || null;
              if (titleHit) return { issue: titleHit, foundBy: "title" };

              return { issue: null, foundBy: "none" };
            }

            // Embed dual markers at top of body for stable identity via Search API.
            const body = [
              SCOPE_MARKER,
              ID_MARKER,
              "",
              "## Contract parity drift detected",
              "",
              `**Time (UTC):** ${now}`,
              `**Workflow run:** ${runUrl}`,
              "",
              "This repository vendors contract artifacts from the producer repo. The nightly observer checks parity against upstream `main` and detected drift.",
              "",
              "### Next actions",
              "1. Review the drift report below.",
              "2. Decide whether to update the pinned `UPSTREAM_REF` tag (preferred) or sync vendored contracts.",
              "3. If producer changes are intentional, cut a new producer release tag and update this repo's pin.",
              "",
              "### Drift report",
              "```",
              clippedReport.trimEnd(),
              "```",
              "",
              "_This issue is maintained automatically and will be updated on subsequent drift detections._"
            ].join("\n");

            // Find rolling issue:
            //  - Prefer ID marker identity
            //  - Fall back to scope marker, then exact title if markers got removed
            let found = await findRollingIssue("open");
            let existing = found.issue;
            let reopened = false;
            let foundBy = found.foundBy;

            if (!existing) {
              found = await findRollingIssue("closed");
              existing = found.issue;
              foundBy = found.foundBy;
              if (existing) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  state: "open"
                });
                reopened = true;
                core.info(`Reopened issue #${existing.number}`);
              }
            }

            if (!existing) {
              // Still not found: create it once.
              const created = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: ISSUE_TITLE,
                body,
                labels: LABELS
              });
              existing = created.data;
              foundBy = "created";
              core.info(`Created issue: ${created.data.html_url}`);
            } else {
              // If found by fallback (title/scope), markers may be missing or partial.
              // Enforce dual markers (self-healing).
              const patchedBody = ensureDualMarkers(existing.body || "");
              if ((existing.body || "") !== patchedBody) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  body: patchedBody
                });
                core.info(`Enforced dual markers on issue #${existing.number} (found by: ${foundBy}).`);
                existing = { ...existing, body: patchedBody };
              }

              // Ensure title is set (optional cosmetic) while marker remains identity.
              // This is safe even if someone renamed it manually.
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  title: ISSUE_TITLE
                });
              } catch (e) {
                core.info(`Could not set title (non-fatal): ${e}`);
              }

              // Ensure labels exist on the rolling issue (non-fatal if labels are restricted).
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existing.number,
                  labels: LABELS
                });
              } catch (e) {
                core.info(`Could not add labels (may be restricted): ${e}`);
              }
            }

            // Update body (keeps latest report visible)
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body
            });

            // Add comment (keeps a timeline of drift detections)
            const comment = [
              reopened ? `ðŸ”„ Drift detected again (issue reopened) at **${now}**.` : `Drift detected again at **${now}**.`,
              `Workflow run: ${runUrl}`,
              "",
              `_Rolling issue identity: dual-marker (fallback used: ${foundBy})._`,
              "",
              "```",
              clippedReport.trimEnd(),
              "```"
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            core.info(`Updated and commented on issue #${existing.number}`);

      - name: Auto-close rolling drift issue when parity returns to green
        if: steps.parity.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const ISSUE_TITLE = "Upstream contract drift detected";
            const SCOPE_MARKER = "<!-- drift-rolling-issue: contracts -->";
            const ID_MARKER = "<!-- drift-rolling-issue-id: contracts:9d3f1a2c -->";
            const now = new Date().toISOString();
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            const repoQ = `repo:${context.repo.owner}/${context.repo.repo}`;

            async function searchOne(query) {
              const res = await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 10
              });
              return res.data.items || [];
            }

            function hasBothMarkers(body) {
              const b = body || "";
              return b.includes(SCOPE_MARKER) && b.includes(ID_MARKER);
            }
            function ensureDualMarkers(body) {
              const b = (body || "").trimStart();
              if (hasBothMarkers(b)) return b;
              const cleaned = b
                .replaceAll(SCOPE_MARKER, "")
                .replaceAll(ID_MARKER, "")
                .trimStart();
              return `${SCOPE_MARKER}\n${ID_MARKER}\n\n${cleaned}`;
            }

            // Prefer ID-marker identity; fall back to scope-marker, then exact title.
            let foundBy = "id_marker";
            let items = await searchOne(`${repoQ} is:issue in:body "${ID_MARKER}" is:open`);
            let existing = items.find(i => (i.body || "").includes(ID_MARKER)) || null;

            if (!existing) {
              foundBy = "scope_marker";
              items = await searchOne(`${repoQ} is:issue in:body "${SCOPE_MARKER}" is:open`);
              existing = items.find(i => (i.body || "").includes(SCOPE_MARKER)) || null;
            }

            if (!existing) {
              foundBy = "title";
              items = await searchOne(`${repoQ} is:issue in:title "${ISSUE_TITLE}" is:open`);
              existing = items.find(i => i.title === ISSUE_TITLE) || null;
            }

            if (!existing) {
              core.info("No open drift issue found; nothing to close.");
              return;
            }

            // Enforce dual markers (self-healing) before closing.
            const patchedBody = ensureDualMarkers(existing.body || "");
            if ((existing.body || "") !== patchedBody) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: patchedBody
              });
              core.info(`Enforced dual markers on issue #${existing.number} during auto-close (found by: ${foundBy}).`);
            }

            // Comment "Resolved" with context.
            const comment = [
              `âœ… Resolved at **${now}**.`,
              `Parity is green against upstream \`main\`.`,
              `Workflow run: ${runUrl}`,
              "",
              "If drift reappears, this issue will be reopened automatically by the observer.",
              "",
              `_Rolling issue identity: dual-marker (fallback used: ${foundBy})._`
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              body: comment
            });

            // Close the issue.
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existing.number,
              state: "closed"
            });

            core.info(`Closed drift issue #${existing.number}`);

      - name: Summary
        if: always()
        run: |
          echo "Observer workflow complete."
          if [[ "${{ steps.parity.outcome }}" == "failure" ]]; then
            echo "Parity failed: drift issue opened/updated."
          else
            echo "Parity OK: drift issue (if any) auto-closed."
          fi
